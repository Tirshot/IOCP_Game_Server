// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#include "Protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Protocol {
PROTOBUF_CONSTEXPR S_TEST::S_TEST(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.buffs_)*/{}
  , /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_.hp_)*/0u
  , /*decltype(_impl_.attack_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_TESTDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_TESTDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_TESTDefaultTypeInternal() {}
  union {
    S_TEST _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_TESTDefaultTypeInternal _S_TEST_default_instance_;
PROTOBUF_CONSTEXPR S_EnterGame::S_EnterGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_EnterGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_EnterGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_EnterGameDefaultTypeInternal() {}
  union {
    S_EnterGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
PROTOBUF_CONSTEXPR C_LeaveGame::C_LeaveGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountid_)*/uint64_t{0u}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_LeaveGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_LeaveGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_LeaveGameDefaultTypeInternal() {}
  union {
    C_LeaveGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_LeaveGameDefaultTypeInternal _C_LeaveGame_default_instance_;
PROTOBUF_CONSTEXPR S_MyPlayer::S_MyPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_MyPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_MyPlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_MyPlayerDefaultTypeInternal() {}
  union {
    S_MyPlayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_MyPlayerDefaultTypeInternal _S_MyPlayer_default_instance_;
PROTOBUF_CONSTEXPR S_AddObject::S_AddObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_AddObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_AddObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_AddObjectDefaultTypeInternal() {}
  union {
    S_AddObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_AddObjectDefaultTypeInternal _S_AddObject_default_instance_;
PROTOBUF_CONSTEXPR S_RemoveObject::S_RemoveObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ids_)*/{}
  , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_RemoveObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_RemoveObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_RemoveObjectDefaultTypeInternal() {}
  union {
    S_RemoveObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_RemoveObjectDefaultTypeInternal _S_RemoveObject_default_instance_;
PROTOBUF_CONSTEXPR C_RemoveObject::C_RemoveObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_RemoveObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_RemoveObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_RemoveObjectDefaultTypeInternal() {}
  union {
    C_RemoveObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_RemoveObjectDefaultTypeInternal _C_RemoveObject_default_instance_;
PROTOBUF_CONSTEXPR C_Move::C_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_MoveDefaultTypeInternal() {}
  union {
    C_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_MoveDefaultTypeInternal _C_Move_default_instance_;
PROTOBUF_CONSTEXPR S_Move::S_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_MoveDefaultTypeInternal() {}
  union {
    S_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_MoveDefaultTypeInternal _S_Move_default_instance_;
PROTOBUF_CONSTEXPR C_Fire::C_Fire(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.ownerid_)*/uint64_t{0u}
  , /*decltype(_impl_.tick_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_FireDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_FireDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_FireDefaultTypeInternal() {}
  union {
    C_Fire _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_FireDefaultTypeInternal _C_Fire_default_instance_;
PROTOBUF_CONSTEXPR S_Fire::S_Fire(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.ownerid_)*/uint64_t{0u}
  , /*decltype(_impl_.tick_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_FireDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_FireDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_FireDefaultTypeInternal() {}
  union {
    S_Fire _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_FireDefaultTypeInternal _S_Fire_default_instance_;
PROTOBUF_CONSTEXPR S_Hit::S_Hit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objectid_)*/uint64_t{0u}
  , /*decltype(_impl_.attackerid_)*/uint64_t{0u}
  , /*decltype(_impl_.objecttype_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_HitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_HitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_HitDefaultTypeInternal() {}
  union {
    S_Hit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_HitDefaultTypeInternal _S_Hit_default_instance_;
PROTOBUF_CONSTEXPR C_Hit::C_Hit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.attackerid_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_HitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_HitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_HitDefaultTypeInternal() {}
  union {
    C_Hit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_HitDefaultTypeInternal _C_Hit_default_instance_;
PROTOBUF_CONSTEXPR C_SendMessage::C_SendMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.texts_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_SendMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_SendMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_SendMessageDefaultTypeInternal() {}
  union {
    C_SendMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_SendMessageDefaultTypeInternal _C_SendMessage_default_instance_;
PROTOBUF_CONSTEXPR S_SendMessage::S_SendMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.texts_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_SendMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_SendMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_SendMessageDefaultTypeInternal() {}
  union {
    S_SendMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_SendMessageDefaultTypeInternal _S_SendMessage_default_instance_;
PROTOBUF_CONSTEXPR C_Revive::C_Revive(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_ReviveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_ReviveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_ReviveDefaultTypeInternal() {}
  union {
    C_Revive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_ReviveDefaultTypeInternal _C_Revive_default_instance_;
PROTOBUF_CONSTEXPR C_Teleport::C_Teleport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objectid_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_TeleportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_TeleportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_TeleportDefaultTypeInternal() {}
  union {
    C_Teleport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_TeleportDefaultTypeInternal _C_Teleport_default_instance_;
PROTOBUF_CONSTEXPR S_Teleport::S_Teleport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objectid_)*/uint64_t{0u}
  , /*decltype(_impl_.posx_)*/0
  , /*decltype(_impl_.posy_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_TeleportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_TeleportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_TeleportDefaultTypeInternal() {}
  union {
    S_Teleport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_TeleportDefaultTypeInternal _S_Teleport_default_instance_;
PROTOBUF_CONSTEXPR S_Gold::S_Gold(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objectid_)*/uint64_t{0u}
  , /*decltype(_impl_.gold_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_GoldDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_GoldDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_GoldDefaultTypeInternal() {}
  union {
    S_Gold _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_GoldDefaultTypeInternal _S_Gold_default_instance_;
}  // namespace Protocol
static ::_pb::Metadata file_level_metadata_Protocol_2eproto[19];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_Protocol_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Protocol_2eproto = nullptr;

const uint32_t TableStruct_Protocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.hp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.attack_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_TEST, _impl_.buffs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _impl_.accountid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_LeaveGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_LeaveGame, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_LeaveGame, _impl_.accountid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_MyPlayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_MyPlayer, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_AddObject, _impl_.objects_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RemoveObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RemoveObject, _impl_.ids_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_RemoveObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_RemoveObject, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Move, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Fire, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Fire, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Fire, _impl_.ownerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Fire, _impl_.tick_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Fire, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Fire, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Fire, _impl_.ownerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Fire, _impl_.tick_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Hit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Hit, _impl_.objectid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Hit, _impl_.attackerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Hit, _impl_.objecttype_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Hit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Hit, _impl_.info_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Hit, _impl_.attackerid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_SendMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_SendMessage, _impl_.texts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_SendMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_SendMessage, _impl_.texts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Revive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Revive, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Teleport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Teleport, _impl_.objectid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Teleport, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Teleport, _impl_.objectid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Teleport, _impl_.posx_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Teleport, _impl_.posy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Gold, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Gold, _impl_.objectid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Gold, _impl_.gold_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Protocol::S_TEST)},
  { 10, -1, -1, sizeof(::Protocol::S_EnterGame)},
  { 18, -1, -1, sizeof(::Protocol::C_LeaveGame)},
  { 26, -1, -1, sizeof(::Protocol::S_MyPlayer)},
  { 33, -1, -1, sizeof(::Protocol::S_AddObject)},
  { 40, -1, -1, sizeof(::Protocol::S_RemoveObject)},
  { 47, -1, -1, sizeof(::Protocol::C_RemoveObject)},
  { 54, -1, -1, sizeof(::Protocol::C_Move)},
  { 61, -1, -1, sizeof(::Protocol::S_Move)},
  { 68, -1, -1, sizeof(::Protocol::C_Fire)},
  { 77, -1, -1, sizeof(::Protocol::S_Fire)},
  { 86, -1, -1, sizeof(::Protocol::S_Hit)},
  { 95, -1, -1, sizeof(::Protocol::C_Hit)},
  { 103, -1, -1, sizeof(::Protocol::C_SendMessage)},
  { 110, -1, -1, sizeof(::Protocol::S_SendMessage)},
  { 117, -1, -1, sizeof(::Protocol::C_Revive)},
  { 124, -1, -1, sizeof(::Protocol::C_Teleport)},
  { 131, -1, -1, sizeof(::Protocol::S_Teleport)},
  { 140, -1, -1, sizeof(::Protocol::S_Gold)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Protocol::_S_TEST_default_instance_._instance,
  &::Protocol::_S_EnterGame_default_instance_._instance,
  &::Protocol::_C_LeaveGame_default_instance_._instance,
  &::Protocol::_S_MyPlayer_default_instance_._instance,
  &::Protocol::_S_AddObject_default_instance_._instance,
  &::Protocol::_S_RemoveObject_default_instance_._instance,
  &::Protocol::_C_RemoveObject_default_instance_._instance,
  &::Protocol::_C_Move_default_instance_._instance,
  &::Protocol::_S_Move_default_instance_._instance,
  &::Protocol::_C_Fire_default_instance_._instance,
  &::Protocol::_S_Fire_default_instance_._instance,
  &::Protocol::_S_Hit_default_instance_._instance,
  &::Protocol::_C_Hit_default_instance_._instance,
  &::Protocol::_C_SendMessage_default_instance_._instance,
  &::Protocol::_S_SendMessage_default_instance_._instance,
  &::Protocol::_C_Revive_default_instance_._instance,
  &::Protocol::_C_Teleport_default_instance_._instance,
  &::Protocol::_S_Teleport_default_instance_._instance,
  &::Protocol::_S_Gold_default_instance_._instance,
};

const char descriptor_table_protodef_Protocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016Protocol.proto\022\010Protocol\032\nEnum.proto\032\014"
  "Struct.proto\"S\n\006S_TEST\022\n\n\002id\030\001 \001(\004\022\n\n\002hp"
  "\030\002 \001(\r\022\016\n\006attack\030\003 \001(\r\022!\n\005buffs\030\004 \003(\0132\022."
  "Protocol.BuffData\"1\n\013S_EnterGame\022\017\n\007succ"
  "ess\030\001 \001(\010\022\021\n\taccountId\030\002 \001(\004\"1\n\013C_LeaveG"
  "ame\022\017\n\007success\030\001 \001(\010\022\021\n\taccountId\030\002 \001(\004\""
  "0\n\nS_MyPlayer\022\"\n\004info\030\001 \001(\0132\024.Protocol.O"
  "bjectInfo\"4\n\013S_AddObject\022%\n\007objects\030\001 \003("
  "\0132\024.Protocol.ObjectInfo\"\035\n\016S_RemoveObjec"
  "t\022\013\n\003ids\030\001 \003(\004\"\034\n\016C_RemoveObject\022\n\n\002id\030\001"
  " \001(\004\",\n\006C_Move\022\"\n\004info\030\001 \001(\0132\024.Protocol."
  "ObjectInfo\",\n\006S_Move\022\"\n\004info\030\001 \001(\0132\024.Pro"
  "tocol.ObjectInfo\"K\n\006C_Fire\022\"\n\004info\030\001 \001(\013"
  "2\024.Protocol.ObjectInfo\022\017\n\007ownerid\030\002 \001(\004\022"
  "\014\n\004tick\030\003 \001(\004\"K\n\006S_Fire\022\"\n\004info\030\001 \001(\0132\024."
  "Protocol.ObjectInfo\022\017\n\007ownerid\030\002 \001(\004\022\014\n\004"
  "tick\030\003 \001(\004\"A\n\005S_Hit\022\020\n\010objectid\030\001 \001(\004\022\022\n"
  "\nattackerid\030\002 \001(\004\022\022\n\nobjecttype\030\003 \001(\004\"\?\n"
  "\005C_Hit\022\"\n\004info\030\001 \001(\0132\024.Protocol.ObjectIn"
  "fo\022\022\n\nattackerid\030\002 \001(\004\".\n\rC_SendMessage\022"
  "\035\n\005texts\030\001 \001(\0132\016.Protocol.Text\".\n\rS_Send"
  "Message\022\035\n\005texts\030\001 \001(\0132\016.Protocol.Text\"."
  "\n\010C_Revive\022\"\n\004info\030\001 \001(\0132\024.Protocol.Obje"
  "ctInfo\"\036\n\nC_Teleport\022\020\n\010objectId\030\001 \001(\004\":"
  "\n\nS_Teleport\022\020\n\010objectId\030\001 \001(\004\022\014\n\004posX\030\002"
  " \001(\005\022\014\n\004posY\030\003 \001(\005\"(\n\006S_Gold\022\020\n\010objectId"
  "\030\001 \001(\004\022\014\n\004gold\030\002 \001(\005b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_Protocol_2eproto_deps[2] = {
  &::descriptor_table_Enum_2eproto,
  &::descriptor_table_Struct_2eproto,
};
static ::_pbi::once_flag descriptor_table_Protocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Protocol_2eproto = {
    false, false, 1068, descriptor_table_protodef_Protocol_2eproto,
    "Protocol.proto",
    &descriptor_table_Protocol_2eproto_once, descriptor_table_Protocol_2eproto_deps, 2, 19,
    schemas, file_default_instances, TableStruct_Protocol_2eproto::offsets,
    file_level_metadata_Protocol_2eproto, file_level_enum_descriptors_Protocol_2eproto,
    file_level_service_descriptors_Protocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Protocol_2eproto_getter() {
  return &descriptor_table_Protocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Protocol_2eproto(&descriptor_table_Protocol_2eproto);
namespace Protocol {

// ===================================================================

class S_TEST::_Internal {
 public:
};

void S_TEST::clear_buffs() {
  _impl_.buffs_.Clear();
}
S_TEST::S_TEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_TEST)
}
S_TEST::S_TEST(const S_TEST& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_TEST* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.buffs_){from._impl_.buffs_}
    , decltype(_impl_.id_){}
    , decltype(_impl_.hp_){}
    , decltype(_impl_.attack_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.attack_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.attack_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_TEST)
}

inline void S_TEST::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.buffs_){arena}
    , decltype(_impl_.id_){uint64_t{0u}}
    , decltype(_impl_.hp_){0u}
    , decltype(_impl_.attack_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_TEST::~S_TEST() {
  // @@protoc_insertion_point(destructor:Protocol.S_TEST)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_TEST::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.buffs_.~RepeatedPtrField();
}

void S_TEST::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_TEST::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_TEST)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.buffs_.Clear();
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.attack_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.attack_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_TEST::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 hp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.hp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 attack = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.attack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Protocol.BuffData buffs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buffs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_TEST::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_TEST)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // uint32 hp = 2;
  if (this->_internal_hp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hp(), target);
  }

  // uint32 attack = 3;
  if (this->_internal_attack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_attack(), target);
  }

  // repeated .Protocol.BuffData buffs = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buffs_size()); i < n; i++) {
    const auto& repfield = this->_internal_buffs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_TEST)
  return target;
}

size_t S_TEST::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_TEST)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.BuffData buffs = 4;
  total_size += 1UL * this->_internal_buffs_size();
  for (const auto& msg : this->_impl_.buffs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  // uint32 hp = 2;
  if (this->_internal_hp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hp());
  }

  // uint32 attack = 3;
  if (this->_internal_attack() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_attack());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_TEST::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_TEST::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_TEST::GetClassData() const { return &_class_data_; }


void S_TEST::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_TEST*>(&to_msg);
  auto& from = static_cast<const S_TEST&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_TEST)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.buffs_.MergeFrom(from._impl_.buffs_);
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_hp() != 0) {
    _this->_internal_set_hp(from._internal_hp());
  }
  if (from._internal_attack() != 0) {
    _this->_internal_set_attack(from._internal_attack());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_TEST::CopyFrom(const S_TEST& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_TEST)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_TEST::IsInitialized() const {
  return true;
}

void S_TEST::InternalSwap(S_TEST* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.buffs_.InternalSwap(&other->_impl_.buffs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_TEST, _impl_.attack_)
      + sizeof(S_TEST::_impl_.attack_)
      - PROTOBUF_FIELD_OFFSET(S_TEST, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_TEST::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[0]);
}

// ===================================================================

class S_EnterGame::_Internal {
 public:
};

S_EnterGame::S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_EnterGame)
}
S_EnterGame::S_EnterGame(const S_EnterGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_EnterGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.success_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_EnterGame)
}

inline void S_EnterGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_EnterGame::~S_EnterGame() {
  // @@protoc_insertion_point(destructor:Protocol.S_EnterGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_EnterGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_EnterGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_EnterGame::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_EnterGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.success_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.success_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_EnterGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 accountId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_EnterGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_EnterGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // uint64 accountId = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_EnterGame)
  return target;
}

size_t S_EnterGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_EnterGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 accountId = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_EnterGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_EnterGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_EnterGame::GetClassData() const { return &_class_data_; }


void S_EnterGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_EnterGame*>(&to_msg);
  auto& from = static_cast<const S_EnterGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_EnterGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_EnterGame::CopyFrom(const S_EnterGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_EnterGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_EnterGame::IsInitialized() const {
  return true;
}

void S_EnterGame::InternalSwap(S_EnterGame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_EnterGame, _impl_.success_)
      + sizeof(S_EnterGame::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(S_EnterGame, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_EnterGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[1]);
}

// ===================================================================

class C_LeaveGame::_Internal {
 public:
};

C_LeaveGame::C_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_LeaveGame)
}
C_LeaveGame::C_LeaveGame(const C_LeaveGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_LeaveGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountid_, &from._impl_.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.success_) -
    reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.success_));
  // @@protoc_insertion_point(copy_constructor:Protocol.C_LeaveGame)
}

inline void C_LeaveGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountid_){uint64_t{0u}}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_LeaveGame::~C_LeaveGame() {
  // @@protoc_insertion_point(destructor:Protocol.C_LeaveGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_LeaveGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_LeaveGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_LeaveGame::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_LeaveGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.success_) -
      reinterpret_cast<char*>(&_impl_.accountid_)) + sizeof(_impl_.success_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_LeaveGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 accountId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_LeaveGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_LeaveGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // uint64 accountId = 2;
  if (this->_internal_accountid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_accountid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_LeaveGame)
  return target;
}

size_t C_LeaveGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_LeaveGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 accountId = 2;
  if (this->_internal_accountid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_accountid());
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_LeaveGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_LeaveGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_LeaveGame::GetClassData() const { return &_class_data_; }


void C_LeaveGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_LeaveGame*>(&to_msg);
  auto& from = static_cast<const C_LeaveGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_LeaveGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountid() != 0) {
    _this->_internal_set_accountid(from._internal_accountid());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_LeaveGame::CopyFrom(const C_LeaveGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_LeaveGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_LeaveGame::IsInitialized() const {
  return true;
}

void C_LeaveGame::InternalSwap(C_LeaveGame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(C_LeaveGame, _impl_.success_)
      + sizeof(C_LeaveGame::_impl_.success_)
      - PROTOBUF_FIELD_OFFSET(C_LeaveGame, _impl_.accountid_)>(
          reinterpret_cast<char*>(&_impl_.accountid_),
          reinterpret_cast<char*>(&other->_impl_.accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata C_LeaveGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[2]);
}

// ===================================================================

class S_MyPlayer::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const S_MyPlayer* msg);
};

const ::Protocol::ObjectInfo&
S_MyPlayer::_Internal::info(const S_MyPlayer* msg) {
  return *msg->_impl_.info_;
}
void S_MyPlayer::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
S_MyPlayer::S_MyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_MyPlayer)
}
S_MyPlayer::S_MyPlayer(const S_MyPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_MyPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_MyPlayer)
}

inline void S_MyPlayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_MyPlayer::~S_MyPlayer() {
  // @@protoc_insertion_point(destructor:Protocol.S_MyPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_MyPlayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_MyPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_MyPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_MyPlayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_MyPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_MyPlayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_MyPlayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_MyPlayer)
  return target;
}

size_t S_MyPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_MyPlayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_MyPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_MyPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_MyPlayer::GetClassData() const { return &_class_data_; }


void S_MyPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_MyPlayer*>(&to_msg);
  auto& from = static_cast<const S_MyPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_MyPlayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_MyPlayer::CopyFrom(const S_MyPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_MyPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_MyPlayer::IsInitialized() const {
  return true;
}

void S_MyPlayer::InternalSwap(S_MyPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_MyPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[3]);
}

// ===================================================================

class S_AddObject::_Internal {
 public:
};

void S_AddObject::clear_objects() {
  _impl_.objects_.Clear();
}
S_AddObject::S_AddObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_AddObject)
}
S_AddObject::S_AddObject(const S_AddObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_AddObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){from._impl_.objects_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_AddObject)
}

inline void S_AddObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_AddObject::~S_AddObject() {
  // @@protoc_insertion_point(destructor:Protocol.S_AddObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_AddObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void S_AddObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_AddObject::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_AddObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_AddObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Protocol.ObjectInfo objects = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_AddObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_AddObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Protocol.ObjectInfo objects = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_AddObject)
  return target;
}

size_t S_AddObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_AddObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.ObjectInfo objects = 1;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_AddObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_AddObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_AddObject::GetClassData() const { return &_class_data_; }


void S_AddObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_AddObject*>(&to_msg);
  auto& from = static_cast<const S_AddObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_AddObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_AddObject::CopyFrom(const S_AddObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_AddObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_AddObject::IsInitialized() const {
  return true;
}

void S_AddObject::InternalSwap(S_AddObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_AddObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[4]);
}

// ===================================================================

class S_RemoveObject::_Internal {
 public:
};

S_RemoveObject::S_RemoveObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_RemoveObject)
}
S_RemoveObject::S_RemoveObject(const S_RemoveObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_RemoveObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){from._impl_.ids_}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_RemoveObject)
}

inline void S_RemoveObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ids_){arena}
    , /*decltype(_impl_._ids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_RemoveObject::~S_RemoveObject() {
  // @@protoc_insertion_point(destructor:Protocol.S_RemoveObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_RemoveObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ids_.~RepeatedField();
}

void S_RemoveObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_RemoveObject::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_RemoveObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_RemoveObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_ids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_RemoveObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_RemoveObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 ids = 1;
  {
    int byte_size = _impl_._ids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_ids(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_RemoveObject)
  return target;
}

size_t S_RemoveObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_RemoveObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.ids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._ids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_RemoveObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_RemoveObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_RemoveObject::GetClassData() const { return &_class_data_; }


void S_RemoveObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_RemoveObject*>(&to_msg);
  auto& from = static_cast<const S_RemoveObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_RemoveObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ids_.MergeFrom(from._impl_.ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_RemoveObject::CopyFrom(const S_RemoveObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_RemoveObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_RemoveObject::IsInitialized() const {
  return true;
}

void S_RemoveObject::InternalSwap(S_RemoveObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ids_.InternalSwap(&other->_impl_.ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_RemoveObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[5]);
}

// ===================================================================

class C_RemoveObject::_Internal {
 public:
};

C_RemoveObject::C_RemoveObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_RemoveObject)
}
C_RemoveObject::C_RemoveObject(const C_RemoveObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_RemoveObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_RemoveObject)
}

inline void C_RemoveObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_RemoveObject::~C_RemoveObject() {
  // @@protoc_insertion_point(destructor:Protocol.C_RemoveObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_RemoveObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_RemoveObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_RemoveObject::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_RemoveObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_RemoveObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_RemoveObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_RemoveObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_RemoveObject)
  return target;
}

size_t C_RemoveObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_RemoveObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_RemoveObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_RemoveObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_RemoveObject::GetClassData() const { return &_class_data_; }


void C_RemoveObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_RemoveObject*>(&to_msg);
  auto& from = static_cast<const C_RemoveObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_RemoveObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_RemoveObject::CopyFrom(const C_RemoveObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_RemoveObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_RemoveObject::IsInitialized() const {
  return true;
}

void C_RemoveObject::InternalSwap(C_RemoveObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_RemoveObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[6]);
}

// ===================================================================

class C_Move::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const C_Move* msg);
};

const ::Protocol::ObjectInfo&
C_Move::_Internal::info(const C_Move* msg) {
  return *msg->_impl_.info_;
}
void C_Move::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
C_Move::C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Move)
}
C_Move::C_Move(const C_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Move)
}

inline void C_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Move::~C_Move() {
  // @@protoc_insertion_point(destructor:Protocol.C_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void C_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Move)
  return target;
}

size_t C_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Move::GetClassData() const { return &_class_data_; }


void C_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Move*>(&to_msg);
  auto& from = static_cast<const C_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Move::CopyFrom(const C_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Move::IsInitialized() const {
  return true;
}

void C_Move::InternalSwap(C_Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[7]);
}

// ===================================================================

class S_Move::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const S_Move* msg);
};

const ::Protocol::ObjectInfo&
S_Move::_Internal::info(const S_Move* msg) {
  return *msg->_impl_.info_;
}
void S_Move::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
S_Move::S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Move)
}
S_Move::S_Move(const S_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Move)
}

inline void S_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Move::~S_Move() {
  // @@protoc_insertion_point(destructor:Protocol.S_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Move)
  return target;
}

size_t S_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Move::GetClassData() const { return &_class_data_; }


void S_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Move*>(&to_msg);
  auto& from = static_cast<const S_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Move::CopyFrom(const S_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Move::IsInitialized() const {
  return true;
}

void S_Move::InternalSwap(S_Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[8]);
}

// ===================================================================

class C_Fire::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const C_Fire* msg);
};

const ::Protocol::ObjectInfo&
C_Fire::_Internal::info(const C_Fire* msg) {
  return *msg->_impl_.info_;
}
void C_Fire::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
C_Fire::C_Fire(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Fire)
}
C_Fire::C_Fire(const C_Fire& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Fire* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.ownerid_){}
    , decltype(_impl_.tick_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  ::memcpy(&_impl_.ownerid_, &from._impl_.ownerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tick_) -
    reinterpret_cast<char*>(&_impl_.ownerid_)) + sizeof(_impl_.tick_));
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Fire)
}

inline void C_Fire::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.ownerid_){uint64_t{0u}}
    , decltype(_impl_.tick_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Fire::~C_Fire() {
  // @@protoc_insertion_point(destructor:Protocol.C_Fire)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Fire::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void C_Fire::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Fire::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Fire)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  ::memset(&_impl_.ownerid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tick_) -
      reinterpret_cast<char*>(&_impl_.ownerid_)) + sizeof(_impl_.tick_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Fire::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 ownerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ownerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Fire::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Fire)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // uint64 ownerid = 2;
  if (this->_internal_ownerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ownerid(), target);
  }

  // uint64 tick = 3;
  if (this->_internal_tick() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Fire)
  return target;
}

size_t C_Fire::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Fire)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  // uint64 ownerid = 2;
  if (this->_internal_ownerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ownerid());
  }

  // uint64 tick = 3;
  if (this->_internal_tick() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tick());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Fire::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Fire::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Fire::GetClassData() const { return &_class_data_; }


void C_Fire::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Fire*>(&to_msg);
  auto& from = static_cast<const C_Fire&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Fire)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  if (from._internal_ownerid() != 0) {
    _this->_internal_set_ownerid(from._internal_ownerid());
  }
  if (from._internal_tick() != 0) {
    _this->_internal_set_tick(from._internal_tick());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Fire::CopyFrom(const C_Fire& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Fire)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Fire::IsInitialized() const {
  return true;
}

void C_Fire::InternalSwap(C_Fire* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(C_Fire, _impl_.tick_)
      + sizeof(C_Fire::_impl_.tick_)
      - PROTOBUF_FIELD_OFFSET(C_Fire, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Fire::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[9]);
}

// ===================================================================

class S_Fire::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const S_Fire* msg);
};

const ::Protocol::ObjectInfo&
S_Fire::_Internal::info(const S_Fire* msg) {
  return *msg->_impl_.info_;
}
void S_Fire::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
S_Fire::S_Fire(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Fire)
}
S_Fire::S_Fire(const S_Fire& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Fire* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.ownerid_){}
    , decltype(_impl_.tick_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  ::memcpy(&_impl_.ownerid_, &from._impl_.ownerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tick_) -
    reinterpret_cast<char*>(&_impl_.ownerid_)) + sizeof(_impl_.tick_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Fire)
}

inline void S_Fire::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.ownerid_){uint64_t{0u}}
    , decltype(_impl_.tick_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Fire::~S_Fire() {
  // @@protoc_insertion_point(destructor:Protocol.S_Fire)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Fire::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_Fire::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Fire::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Fire)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  ::memset(&_impl_.ownerid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.tick_) -
      reinterpret_cast<char*>(&_impl_.ownerid_)) + sizeof(_impl_.tick_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Fire::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 ownerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.ownerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 tick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Fire::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Fire)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // uint64 ownerid = 2;
  if (this->_internal_ownerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_ownerid(), target);
  }

  // uint64 tick = 3;
  if (this->_internal_tick() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_tick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Fire)
  return target;
}

size_t S_Fire::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Fire)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  // uint64 ownerid = 2;
  if (this->_internal_ownerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_ownerid());
  }

  // uint64 tick = 3;
  if (this->_internal_tick() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tick());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Fire::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Fire::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Fire::GetClassData() const { return &_class_data_; }


void S_Fire::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Fire*>(&to_msg);
  auto& from = static_cast<const S_Fire&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Fire)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  if (from._internal_ownerid() != 0) {
    _this->_internal_set_ownerid(from._internal_ownerid());
  }
  if (from._internal_tick() != 0) {
    _this->_internal_set_tick(from._internal_tick());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Fire::CopyFrom(const S_Fire& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Fire)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Fire::IsInitialized() const {
  return true;
}

void S_Fire::InternalSwap(S_Fire* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Fire, _impl_.tick_)
      + sizeof(S_Fire::_impl_.tick_)
      - PROTOBUF_FIELD_OFFSET(S_Fire, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Fire::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[10]);
}

// ===================================================================

class S_Hit::_Internal {
 public:
};

S_Hit::S_Hit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Hit)
}
S_Hit::S_Hit(const S_Hit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Hit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){}
    , decltype(_impl_.attackerid_){}
    , decltype(_impl_.objecttype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.objectid_, &from._impl_.objectid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.objecttype_) -
    reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.objecttype_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Hit)
}

inline void S_Hit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){uint64_t{0u}}
    , decltype(_impl_.attackerid_){uint64_t{0u}}
    , decltype(_impl_.objecttype_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Hit::~S_Hit() {
  // @@protoc_insertion_point(destructor:Protocol.S_Hit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Hit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Hit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Hit::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Hit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.objectid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.objecttype_) -
      reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.objecttype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Hit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 objectid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 attackerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.attackerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 objecttype = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.objecttype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Hit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Hit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 objectid = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_objectid(), target);
  }

  // uint64 attackerid = 2;
  if (this->_internal_attackerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_attackerid(), target);
  }

  // uint64 objecttype = 3;
  if (this->_internal_objecttype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_objecttype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Hit)
  return target;
}

size_t S_Hit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Hit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 objectid = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_objectid());
  }

  // uint64 attackerid = 2;
  if (this->_internal_attackerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_attackerid());
  }

  // uint64 objecttype = 3;
  if (this->_internal_objecttype() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_objecttype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Hit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Hit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Hit::GetClassData() const { return &_class_data_; }


void S_Hit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Hit*>(&to_msg);
  auto& from = static_cast<const S_Hit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Hit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  if (from._internal_attackerid() != 0) {
    _this->_internal_set_attackerid(from._internal_attackerid());
  }
  if (from._internal_objecttype() != 0) {
    _this->_internal_set_objecttype(from._internal_objecttype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Hit::CopyFrom(const S_Hit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Hit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Hit::IsInitialized() const {
  return true;
}

void S_Hit::InternalSwap(S_Hit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Hit, _impl_.objecttype_)
      + sizeof(S_Hit::_impl_.objecttype_)
      - PROTOBUF_FIELD_OFFSET(S_Hit, _impl_.objectid_)>(
          reinterpret_cast<char*>(&_impl_.objectid_),
          reinterpret_cast<char*>(&other->_impl_.objectid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Hit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[11]);
}

// ===================================================================

class C_Hit::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const C_Hit* msg);
};

const ::Protocol::ObjectInfo&
C_Hit::_Internal::info(const C_Hit* msg) {
  return *msg->_impl_.info_;
}
void C_Hit::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
C_Hit::C_Hit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Hit)
}
C_Hit::C_Hit(const C_Hit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Hit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.attackerid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  _this->_impl_.attackerid_ = from._impl_.attackerid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Hit)
}

inline void C_Hit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.attackerid_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Hit::~C_Hit() {
  // @@protoc_insertion_point(destructor:Protocol.C_Hit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Hit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void C_Hit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Hit::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Hit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _impl_.attackerid_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Hit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 attackerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.attackerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Hit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Hit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  // uint64 attackerid = 2;
  if (this->_internal_attackerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_attackerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Hit)
  return target;
}

size_t C_Hit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Hit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  // uint64 attackerid = 2;
  if (this->_internal_attackerid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_attackerid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Hit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Hit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Hit::GetClassData() const { return &_class_data_; }


void C_Hit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Hit*>(&to_msg);
  auto& from = static_cast<const C_Hit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Hit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  if (from._internal_attackerid() != 0) {
    _this->_internal_set_attackerid(from._internal_attackerid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Hit::CopyFrom(const C_Hit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Hit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Hit::IsInitialized() const {
  return true;
}

void C_Hit::InternalSwap(C_Hit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(C_Hit, _impl_.attackerid_)
      + sizeof(C_Hit::_impl_.attackerid_)
      - PROTOBUF_FIELD_OFFSET(C_Hit, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Hit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[12]);
}

// ===================================================================

class C_SendMessage::_Internal {
 public:
  static const ::Protocol::Text& texts(const C_SendMessage* msg);
};

const ::Protocol::Text&
C_SendMessage::_Internal::texts(const C_SendMessage* msg) {
  return *msg->_impl_.texts_;
}
void C_SendMessage::clear_texts() {
  if (GetArenaForAllocation() == nullptr && _impl_.texts_ != nullptr) {
    delete _impl_.texts_;
  }
  _impl_.texts_ = nullptr;
}
C_SendMessage::C_SendMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_SendMessage)
}
C_SendMessage::C_SendMessage(const C_SendMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_SendMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.texts_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_texts()) {
    _this->_impl_.texts_ = new ::Protocol::Text(*from._impl_.texts_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.C_SendMessage)
}

inline void C_SendMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.texts_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_SendMessage::~C_SendMessage() {
  // @@protoc_insertion_point(destructor:Protocol.C_SendMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_SendMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.texts_;
}

void C_SendMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_SendMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_SendMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.texts_ != nullptr) {
    delete _impl_.texts_;
  }
  _impl_.texts_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_SendMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.Text texts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_texts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_SendMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_SendMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.Text texts = 1;
  if (this->_internal_has_texts()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::texts(this),
        _Internal::texts(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_SendMessage)
  return target;
}

size_t C_SendMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_SendMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.Text texts = 1;
  if (this->_internal_has_texts()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.texts_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_SendMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_SendMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_SendMessage::GetClassData() const { return &_class_data_; }


void C_SendMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_SendMessage*>(&to_msg);
  auto& from = static_cast<const C_SendMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_SendMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_texts()) {
    _this->_internal_mutable_texts()->::Protocol::Text::MergeFrom(
        from._internal_texts());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_SendMessage::CopyFrom(const C_SendMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_SendMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_SendMessage::IsInitialized() const {
  return true;
}

void C_SendMessage::InternalSwap(C_SendMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.texts_, other->_impl_.texts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_SendMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[13]);
}

// ===================================================================

class S_SendMessage::_Internal {
 public:
  static const ::Protocol::Text& texts(const S_SendMessage* msg);
};

const ::Protocol::Text&
S_SendMessage::_Internal::texts(const S_SendMessage* msg) {
  return *msg->_impl_.texts_;
}
void S_SendMessage::clear_texts() {
  if (GetArenaForAllocation() == nullptr && _impl_.texts_ != nullptr) {
    delete _impl_.texts_;
  }
  _impl_.texts_ = nullptr;
}
S_SendMessage::S_SendMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_SendMessage)
}
S_SendMessage::S_SendMessage(const S_SendMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_SendMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.texts_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_texts()) {
    _this->_impl_.texts_ = new ::Protocol::Text(*from._impl_.texts_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_SendMessage)
}

inline void S_SendMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.texts_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_SendMessage::~S_SendMessage() {
  // @@protoc_insertion_point(destructor:Protocol.S_SendMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_SendMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.texts_;
}

void S_SendMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_SendMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_SendMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.texts_ != nullptr) {
    delete _impl_.texts_;
  }
  _impl_.texts_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_SendMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.Text texts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_texts(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_SendMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_SendMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.Text texts = 1;
  if (this->_internal_has_texts()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::texts(this),
        _Internal::texts(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_SendMessage)
  return target;
}

size_t S_SendMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_SendMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.Text texts = 1;
  if (this->_internal_has_texts()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.texts_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_SendMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_SendMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_SendMessage::GetClassData() const { return &_class_data_; }


void S_SendMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_SendMessage*>(&to_msg);
  auto& from = static_cast<const S_SendMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_SendMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_texts()) {
    _this->_internal_mutable_texts()->::Protocol::Text::MergeFrom(
        from._internal_texts());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_SendMessage::CopyFrom(const S_SendMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_SendMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_SendMessage::IsInitialized() const {
  return true;
}

void S_SendMessage::InternalSwap(S_SendMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.texts_, other->_impl_.texts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_SendMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[14]);
}

// ===================================================================

class C_Revive::_Internal {
 public:
  static const ::Protocol::ObjectInfo& info(const C_Revive* msg);
};

const ::Protocol::ObjectInfo&
C_Revive::_Internal::info(const C_Revive* msg) {
  return *msg->_impl_.info_;
}
void C_Revive::clear_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
}
C_Revive::C_Revive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Revive)
}
C_Revive::C_Revive(const C_Revive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Revive* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::ObjectInfo(*from._impl_.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Revive)
}

inline void C_Revive::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Revive::~C_Revive() {
  // @@protoc_insertion_point(destructor:Protocol.C_Revive)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Revive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void C_Revive::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Revive::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Revive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Revive::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Revive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Revive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Revive)
  return target;
}

size_t C_Revive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Revive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo info = 1;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Revive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Revive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Revive::GetClassData() const { return &_class_data_; }


void C_Revive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Revive*>(&to_msg);
  auto& from = static_cast<const C_Revive&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Revive)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_info());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Revive::CopyFrom(const C_Revive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Revive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Revive::IsInitialized() const {
  return true;
}

void C_Revive::InternalSwap(C_Revive* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.info_, other->_impl_.info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Revive::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[15]);
}

// ===================================================================

class C_Teleport::_Internal {
 public:
};

C_Teleport::C_Teleport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Teleport)
}
C_Teleport::C_Teleport(const C_Teleport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Teleport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.objectid_ = from._impl_.objectid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Teleport)
}

inline void C_Teleport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Teleport::~C_Teleport() {
  // @@protoc_insertion_point(destructor:Protocol.C_Teleport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Teleport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_Teleport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Teleport::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Teleport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objectid_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Teleport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 objectId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Teleport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Teleport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 objectId = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_objectid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Teleport)
  return target;
}

size_t C_Teleport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Teleport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 objectId = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_objectid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Teleport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Teleport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Teleport::GetClassData() const { return &_class_data_; }


void C_Teleport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Teleport*>(&to_msg);
  auto& from = static_cast<const C_Teleport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Teleport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Teleport::CopyFrom(const C_Teleport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Teleport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Teleport::IsInitialized() const {
  return true;
}

void C_Teleport::InternalSwap(C_Teleport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.objectid_, other->_impl_.objectid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Teleport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[16]);
}

// ===================================================================

class S_Teleport::_Internal {
 public:
};

S_Teleport::S_Teleport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Teleport)
}
S_Teleport::S_Teleport(const S_Teleport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Teleport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){}
    , decltype(_impl_.posx_){}
    , decltype(_impl_.posy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.objectid_, &from._impl_.objectid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.posy_) -
    reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.posy_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Teleport)
}

inline void S_Teleport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){uint64_t{0u}}
    , decltype(_impl_.posx_){0}
    , decltype(_impl_.posy_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Teleport::~S_Teleport() {
  // @@protoc_insertion_point(destructor:Protocol.S_Teleport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Teleport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Teleport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Teleport::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Teleport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.objectid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.posy_) -
      reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.posy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Teleport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 objectId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 posX = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.posx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 posY = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.posy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Teleport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Teleport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 objectId = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_objectid(), target);
  }

  // int32 posX = 2;
  if (this->_internal_posx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_posx(), target);
  }

  // int32 posY = 3;
  if (this->_internal_posy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_posy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Teleport)
  return target;
}

size_t S_Teleport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Teleport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 objectId = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_objectid());
  }

  // int32 posX = 2;
  if (this->_internal_posx() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_posx());
  }

  // int32 posY = 3;
  if (this->_internal_posy() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_posy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Teleport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Teleport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Teleport::GetClassData() const { return &_class_data_; }


void S_Teleport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Teleport*>(&to_msg);
  auto& from = static_cast<const S_Teleport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Teleport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  if (from._internal_posx() != 0) {
    _this->_internal_set_posx(from._internal_posx());
  }
  if (from._internal_posy() != 0) {
    _this->_internal_set_posy(from._internal_posy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Teleport::CopyFrom(const S_Teleport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Teleport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Teleport::IsInitialized() const {
  return true;
}

void S_Teleport::InternalSwap(S_Teleport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Teleport, _impl_.posy_)
      + sizeof(S_Teleport::_impl_.posy_)
      - PROTOBUF_FIELD_OFFSET(S_Teleport, _impl_.objectid_)>(
          reinterpret_cast<char*>(&_impl_.objectid_),
          reinterpret_cast<char*>(&other->_impl_.objectid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Teleport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[17]);
}

// ===================================================================

class S_Gold::_Internal {
 public:
};

S_Gold::S_Gold(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Gold)
}
S_Gold::S_Gold(const S_Gold& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Gold* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){}
    , decltype(_impl_.gold_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.objectid_, &from._impl_.objectid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.gold_) -
    reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.gold_));
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Gold)
}

inline void S_Gold::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){uint64_t{0u}}
    , decltype(_impl_.gold_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Gold::~S_Gold() {
  // @@protoc_insertion_point(destructor:Protocol.S_Gold)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Gold::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Gold::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Gold::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Gold)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.objectid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.gold_) -
      reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.gold_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Gold::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 objectId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 gold = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.gold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Gold::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Gold)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 objectId = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_objectid(), target);
  }

  // int32 gold = 2;
  if (this->_internal_gold() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_gold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Gold)
  return target;
}

size_t S_Gold::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Gold)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 objectId = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_objectid());
  }

  // int32 gold = 2;
  if (this->_internal_gold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_gold());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Gold::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Gold::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Gold::GetClassData() const { return &_class_data_; }


void S_Gold::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Gold*>(&to_msg);
  auto& from = static_cast<const S_Gold&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Gold)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  if (from._internal_gold() != 0) {
    _this->_internal_set_gold(from._internal_gold());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Gold::CopyFrom(const S_Gold& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Gold)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Gold::IsInitialized() const {
  return true;
}

void S_Gold::InternalSwap(S_Gold* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Gold, _impl_.gold_)
      + sizeof(S_Gold::_impl_.gold_)
      - PROTOBUF_FIELD_OFFSET(S_Gold, _impl_.objectid_)>(
          reinterpret_cast<char*>(&_impl_.objectid_),
          reinterpret_cast<char*>(&other->_impl_.objectid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Gold::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[18]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Protocol::S_TEST*
Arena::CreateMaybeMessage< ::Protocol::S_TEST >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_TEST >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_EnterGame*
Arena::CreateMaybeMessage< ::Protocol::S_EnterGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_EnterGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_LeaveGame*
Arena::CreateMaybeMessage< ::Protocol::C_LeaveGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_LeaveGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_MyPlayer*
Arena::CreateMaybeMessage< ::Protocol::S_MyPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_MyPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_AddObject*
Arena::CreateMaybeMessage< ::Protocol::S_AddObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_AddObject >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_RemoveObject*
Arena::CreateMaybeMessage< ::Protocol::S_RemoveObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_RemoveObject >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_RemoveObject*
Arena::CreateMaybeMessage< ::Protocol::C_RemoveObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_RemoveObject >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Move*
Arena::CreateMaybeMessage< ::Protocol::C_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Move*
Arena::CreateMaybeMessage< ::Protocol::S_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Fire*
Arena::CreateMaybeMessage< ::Protocol::C_Fire >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Fire >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Fire*
Arena::CreateMaybeMessage< ::Protocol::S_Fire >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Fire >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Hit*
Arena::CreateMaybeMessage< ::Protocol::S_Hit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Hit >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Hit*
Arena::CreateMaybeMessage< ::Protocol::C_Hit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Hit >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_SendMessage*
Arena::CreateMaybeMessage< ::Protocol::C_SendMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_SendMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_SendMessage*
Arena::CreateMaybeMessage< ::Protocol::S_SendMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_SendMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Revive*
Arena::CreateMaybeMessage< ::Protocol::C_Revive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Revive >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Teleport*
Arena::CreateMaybeMessage< ::Protocol::C_Teleport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Teleport >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Teleport*
Arena::CreateMaybeMessage< ::Protocol::S_Teleport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Teleport >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Gold*
Arena::CreateMaybeMessage< ::Protocol::S_Gold >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Gold >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
